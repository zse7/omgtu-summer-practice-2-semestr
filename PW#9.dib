#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №9. Реализация длительных операций.

**Цель:** Предоставить возможность выполннеия команд, для полного завершения которых требуется более одного вызова Execute.

**Результаты:** После выполнения работы Вы сможете:
1. Выполнять длительные опреации в отдельном потоке без монопольного использования потока в течение длительного времени.
3. Прерывать выполнение таких команд. 


## Задание.
Если для полного выполнения командв потребуется более одного вызова Execute, необходимо такую команду добавить в планировщик.

Для иллюстрации выполнненой работы определить команду

#!csharp

using System;
using System.Collections.Concurrent;
using System.Threading;

#!csharp

public interface ICommand
{
    void Execute();
}


public class TestCommand(int id) : ICommand
{
    int counter = 0;

    public void Execute()
    {
        Console.WriteLine($"Поток {id} вызов {++counter}");
    }
}

#!csharp

public interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}

public class Scheduler : IScheduler
{
    private ConcurrentQueue<ICommand> queue = new ConcurrentQueue<ICommand>();

    public bool HasCommand() //проверка доступных команд
    {
        return !queue.IsEmpty;
    }

    public ICommand Select() //выбор след. команды для выполнения
    {
        queue.TryDequeue(out var command);
        return command;
    }

    public void Add(ICommand cmd) //добавляем новую команду в планировщик 
    {
        queue.Enqueue(cmd);
    }
}

#!csharp

public class WrapperCommand: ICommand
{
    private ICommand command;
    private IScheduler sheduler;
    private int counts = 0;
    private const int max_counts = 3;

    public WrapperCommand(ICommand command, IScheduler sheduler)
    {
        if(command == null) throw new ArgumentNullException(nameof(command));
        if(sheduler == null) throw new ArgumentNullException(nameof(sheduler));

        this.command = command;
        this.sheduler = sheduler;
    }

    public void Execute()
    {
        command.Execute();
        counts++;

        if (counts < max_counts) sheduler.Add(this);
    }
}

#!csharp

public class ServerThread
{
    private Thread thread;
    private IScheduler scheduler = new Scheduler(); 
    private ManualResetEvent commandEvent = new ManualResetEvent(false);
    private bool isRunning = true;
    private bool softStopRequested = false;
    private bool hardStopRequested = false;

    public ServerThread()
    {
        thread = new Thread(Run);
        thread.Start();
    }

    public void EnqueueCommand(ICommand command)
    {
        if (command == null) throw new ArgumentNullException(nameof(command));

        var wrapped_command = new WrapperCommand(command, scheduler);
        scheduler.Add(wrapped_command);
        commandEvent.Set();
    }

    public void RequestSoftStop()
    {
        softStopRequested = true;
        commandEvent.Set();
    }

    public void RequestHardStop()
    {
        hardStopRequested = true;
        isRunning = false;
        commandEvent.Set();
    }

    private void Run()
    {
        while (isRunning || scheduler.HasCommand())
        {
            ICommand command = scheduler.Select();

            if (command != null)
            {
                try
                {
                    command.Execute();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Исключение при выполнении команды: {ex.Message}");
                }
            }
            else
            {
                commandEvent.WaitOne();
                commandEvent.Reset();
            }

            if (hardStopRequested)
                break;
        }

        if (hardStopRequested)
        {
            Console.WriteLine("Запрошена жёсткая остановка. Немедленная остановка потока.");
        }
        else if (softStopRequested)
        {
            Console.WriteLine("Поток мягко остановлен.");
        }
    }

    public void Stop()
    {
        isRunning = false;
        commandEvent.Set();
        thread.Join();
    }
}

#!csharp

public class SoftStop : ICommand
{
    private ServerThread serverThread;

    public SoftStop(ServerThread serverThread)
    {
        if (serverThread == null) throw new ArgumentNullException(nameof(serverThread));
        this.serverThread = serverThread;
    }

    public void Execute()
    {
        serverThread.RequestSoftStop();
    }
}

public class HardStop : ICommand
{
    private ServerThread serverThread;

    public HardStop(ServerThread serverThread)
    {
        if (serverThread == null) throw new ArgumentNullException(nameof(serverThread));
        this.serverThread = serverThread;
    }

    public void Execute()
    {
        serverThread.RequestHardStop();
    }
}

#!csharp

var serverThread = new ServerThread();

for (int i = 1; i <= 5; i++)
{
    serverThread.EnqueueCommand(new TestCommand(i));
}

Thread.Sleep(2000);

serverThread.EnqueueCommand(new HardStop(serverThread));

serverThread.Stop();
Console.WriteLine("Тест завершён.");

#!markdown

Необходимо проиллюстрировать выполнение 5 экземпляров TestCommand 3 раза, затем остановить поток с помощью HardStop.
