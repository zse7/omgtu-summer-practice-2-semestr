#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №8. Реализация планировщика команд.

**Цель:** Реализация длительных операций.

**Результаты:** После выполнения работы Вы сможете:
1. Сделать возможным в потоке выполнять длительные операции.

## Задание.
Пусть, в условиях практической работы №7, у нас есть поток с очередью, который в цикле извлекает команды из очереди и выполняет их.

Некоторые из команд не могут выполнить всю работу за один вызов метода Execute без блокирования на длительное время выполнения всех остальных командд из очереди.

Например, если какая-нибудь сетевая игра представлена командой, то пока одна игра не закончится, следующая не начнется. Чтобы эффективнее использовать процессорные
можности, нужно обеспечить возхможность поиграть как можно большему количеству игроков.

Для этого используют режим псевдопараллельной обработки. Когда все время работы разбивают на небольшие отрезки, каждый из которых выполняется
за один вызов метода Execute. Чтобы выполнить всю работу, нужно вызвать метод Execute несколько раз, до тех пор пока работа не будет завершена.
Это позволяет между вызовами Execute одного экземплыра команды вызывать метод Execute других команд.

Так устроен, например, ренедринг страницы в браузере. Только в браузеоре это используется не для рендеренга всех вкладок, а для обработки 
реакций пользователя на странице.

В прошлой работе все команды, которые выполнялись в потоке, брались из очереди. Поэтому первая идея - это положить долгоиграющую операцию обратно в очередь.
Но это может привести к состоянию мертвой блокировки потока: если очередь будет полна, то поток, который попытается сделать запись, будет заблокирован до тех пор, 
пока в очереди не появится свободное место. Поэтому нельзя в одном и том же потоке читать и писать в очередь неблокируемым образом.

Чтобы избежать мертвой блокировки потока, необходимо ввести понятие Планировщика, который будет отвечать за выбор следующей длительной задачи для выполнения,
а чтение из очереди оставить только для новых операций. 

#!csharp

using System;
using System.Collections.Concurrent;
using System.Threading;

#!csharp

public interface ICommand
{
    void Execute();
}

#!csharp

public interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}

#!csharp

public class TestCommand : ICommand
{
    private string message;
    private bool throwException;

    public TestCommand(string message, bool throwException = false)
    {
        if (message == null) throw new ArgumentNullException(nameof(message));
        this.message = message;
        this.throwException = throwException;
    }

    public void Execute()
    {
        Console.WriteLine($"Выполнение команды: {message}");
        if (throwException) throw new InvalidOperationException("Исключение в команде");
    }
}

#!csharp

public class LongRunningCommand : ICommand
{
    private int step; //счетчик

    public LongRunningCommand(int steps)
    {
        step = steps;
    }

    public void Execute()
    {
        if (step > 0)
        {
            Console.WriteLine($"Выполнение длительной команды. Оставшиеся шаги: {step}");
            step--;
        }
    }
    public bool IsCompleted => step <= 0; //true if все шаги выполнены
}

#!csharp

public class WrapperCommand: ICommand
{
    private ICommand command;
    private IScheduler sheduler;

    public WrapperCommand(ICommand command, IScheduler sheduler)
    {
        if(command == null) throw new ArgumentNullException(nameof(command));
        if(sheduler == null) throw new ArgumentNullException(nameof(sheduler));

        this.command = command;
        this.sheduler = sheduler;
    }

    public void Execute()
    {
        command.Execute();

        if (command is LongRunningCommand longRunningCommand && !longRunningCommand.IsCompleted) sheduler.Add(this);
    }
}

#!csharp

public class Scheduler : IScheduler
{
    private ConcurrentQueue<ICommand> queue = new ConcurrentQueue<ICommand>();

    public bool HasCommand() //проверка доступных команд
    {
        return !queue.IsEmpty;
    }

    public ICommand Select() //выбор след. команды для выполнения
    {
        queue.TryDequeue(out var command);
        return command;
    }

    public void Add(ICommand cmd) //добавляем новую команду в планировщик 
    {
        queue.Enqueue(cmd);
    }
}

#!csharp

public class ServerThread
{
    private Thread thread;
    private IScheduler scheduler = new Scheduler(); 
    private ManualResetEvent commandEvent = new ManualResetEvent(false);
    private bool isRunning = true;
    private bool softStopRequested = false;
    private bool hardStopRequested = false;

    public ServerThread()
    {
        thread = new Thread(Run);
        thread.Start();
    }

    public void EnqueueCommand(ICommand command)
    {
        if (command == null) throw new ArgumentNullException(nameof(command));

        var wrapped_command = new WrapperCommand(command, scheduler);
        scheduler.Add(wrapped_command);
        commandEvent.Set();
    }

    public void RequestSoftStop()
    {
        softStopRequested = true;
        commandEvent.Set();
    }

    public void RequestHardStop()
    {
        hardStopRequested = true;
        isRunning = false;
        commandEvent.Set();
    }

    private void Run()
    {
        while (isRunning || scheduler.HasCommand())
        {
            ICommand command = scheduler.Select();

            if (command != null)
            {
                try
                {
                    command.Execute();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Исключение при выполнении команды: {ex.Message}");
                }
            }
            else
            {
                commandEvent.WaitOne();
                commandEvent.Reset();
            }

            if (hardStopRequested)
                break;
        }

        if (hardStopRequested)
        {
            Console.WriteLine("Запрошена жёсткая остановка. Немедленная остановка потока.");
        }
        else if (softStopRequested)
        {
            Console.WriteLine("Поток мягко остановлен.");
        }
    }

    public void Stop()
    {
        isRunning = false;
        commandEvent.Set();
        thread.Join();
    }
}

#!csharp

public class SoftStop : ICommand
{
    private ServerThread serverThread;

    public SoftStop(ServerThread serverThread)
    {
        if (serverThread == null) throw new ArgumentNullException(nameof(serverThread));
        this.serverThread = serverThread;
    }

    public void Execute()
    {
        serverThread.RequestSoftStop();
    }
}

public class HardStop : ICommand
{
    private ServerThread serverThread;

    public HardStop(ServerThread serverThread)
    {
        if (serverThread == null) throw new ArgumentNullException(nameof(serverThread));
        this.serverThread = serverThread;
    }

    public void Execute()
    {
        serverThread.RequestHardStop();
    }
}

#!csharp

//тест планировщика с длительными операциями
var serverThread = new ServerThread();

serverThread.EnqueueCommand(new TestCommand("Команда 1"));
serverThread.EnqueueCommand(new LongRunningCommand(5));
serverThread.EnqueueCommand(new TestCommand("Команда 2"));
serverThread.EnqueueCommand(new SoftStop(serverThread));

serverThread.Stop();
Console.WriteLine("Тест завершён.");

#!markdown

Необходимо реализовать поток, который способен реализоввывать длительные операции.

**Указание.** 
1. В практической работе №7 из очереди команды извлекались блокируеммым образом с помощью метода Take(), при наличии планировщика так делать нельзя: поток
может заснуть несмотря на наличие команд в планировщике до тех пор, пока не будет записана новая команда в очередь.

С другой стороны, если будем всегда читать неблокируемым образом, а в планировщике нет никакой работы, то будем тратить процессорное время без полезной нагрузки.

Необходимо учесть этот момент при реализации очереди.

2. Для обепечения справедливости стратегии планировщика в слабом смысле использовать стратегию Round Robbin (циклическую) для определения следующего потока на исполнение.
