#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System;
using System.Threading;
using System.Threading.Tasks;
using static System.Threading.Barrier;
using System.Diagnostics;

class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        double sum = 0; //общая сумма
        int steps = (int)((b-a)/step); //общее количество шагов n 
        double steps_ = (b-a)/steps; // шаг разбиения
        Barrier barrier = new Barrier(threadsnumber+1); 
        void Program(int index) 
        {
            double summa = 0; 
            int shag = steps / threadsnumber; //кол-во шагов, которые должен обрабатывать каждый поток
            int the_start = index * shag; //начальный шаг для текущего потока
            int the_end = the_start + shag; //конечный
            if (index == threadsnumber - 1) the_end = steps;
            for (int i = the_start; i < the_end; i++)
            {
                double x_1 = a + i * steps_;
                double x_2 = a + (i + 1) * steps_;
                summa += 0.5 * (function(x_1) + function(x_2)) * steps_;
            }
            double value1, value2;
            do
            {
                value1 = sum; // Сохраняем текущее значение sum
                value2 = value1 + summa; //Вычисляем новое значение
            }
            while (value1 != Interlocked.CompareExchange(ref sum, value2, value1)); //

            barrier.SignalAndWait(); //сигнал о завершении работы потока, пусть теперь ждет другие
        }
        Thread[] threads = new Thread[threadsnumber];
        for (int i = 0; i < threadsnumber; i++)
        {
            int index = i;
            threads[i] = new Thread(() => Program(index));
            threads[i].Start();
        }
        barrier.SignalAndWait(); //основной поток ждет
        return sum;
    }
}

#!csharp

// Install the ScottPlot NuGet package
//#r "nuget:ScottPlot, 5.0.*"

// Setup a custom formatter to display plots as images
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);

#!csharp

//Тестирование различных шагов
void testSteps(double step)
{
    var stopwatch = Stopwatch.StartNew();
    var result = DefiniteIntegral.Solve(-100, 100, Math.Sin, step, 1);
    stopwatch.Stop();
    Console.WriteLine($"Step: {step}, Time: {stopwatch.ElapsedMilliseconds} ms, Res: {result}");
}

// Вызываем для разных шагов
testSteps(1e-1);
testSteps(1e-2);
testSteps(1e-3);
testSteps(1e-4); //оптимальный
testSteps(1e-5);
testSteps(1e-6);
double optimalStep = 1e-4; //найденный оптимальный шаг

#!csharp

//тестирование потоков
void testThreads(int threadsNumber, double step)
{
    var stopwatch = Stopwatch.StartNew();
    var result = DefiniteIntegral.Solve(-100, 100, Math.Sin, step, threadsNumber);
    stopwatch.Stop();
    Console.WriteLine($"Threads: {threadsNumber}, Time: {stopwatch.ElapsedMilliseconds} ms, Result: {result}");
}
double optimalStep = 1e-4; // найденный оптимальный шаг
//вызов для разных количеств потоков
for (int i = 1; i <= 16; i++)
{
    testThreads(i, optimalStep);
}
int optimalThreads = 6; //найденное оптимальное количество потоков

#!csharp

ScottPlot.Plot plt = new();
double[] threads = Enumerable.Range(1, 6).Select(x => x * 1.0).ToArray();
double[] solvings = Enumerable.Range(1, 6).Select(x => 0.0).ToArray();
for (int j = 0; j < 7; j++)
{
    for(int i = 1; i < 7; i++)
    {
    var time = System.Diagnostics.Stopwatch.StartNew();
    DefiniteIntegral.Solve(-100, 100, Math.Sin, 1e-4, i);
    time.Stop();
    solvings[i - 1] += Convert.ToDouble("0," + Convert.ToString(time).Split(".", StringSplitOptions.RemoveEmptyEntries)[1]) / 7;
}}
plt.Add.Scatter(solvings, threads)

#!csharp

//Функция для однопоточного вычисления:
public static double OneThreaded(double a, double b, Func<double, double> function, double step)
{
    double sum = 0;
    int steps = (int)((b - a) / step);
    double steps_ = (b - a) / steps;

    for (int i = 0; i < steps; i++)
    {
        double x_1 = a + i * steps_;
        double x_2 = a + (i + 1) * steps_;
        sum += 0.5 * (function(x_1) + function(x_2)) * steps_;
    }

    return sum;
}
//OneThreaded(-100,100,Math.Sin,optimalStep)

#!csharp

//Сравнение

var stopwatchOne = Stopwatch.StartNew();
var resultOne = OneThreaded(-100, 100, Math.Sin, optimalStep);
stopwatchOne.Stop();
long timeOne = stopwatchSingle.ElapsedMilliseconds;

var stopwatchSeveral = Stopwatch.StartNew();
var resultSeveral = DefiniteIntegral.Solve(-100, 100, Math.Sin, optimalStep, optimalThreads);
stopwatchSeveral.Stop();
long timeSeveral = stopwatchMulti.ElapsedMilliseconds;

Console.WriteLine($"Optimal step: {optimalStep}");
Console.WriteLine($"Optimal threads: {optimalThreads}");
Console.WriteLine($"OneThreaded time: {timeOne} ms");
Console.WriteLine($"SeveralThreaded time: {timeSeveral} ms");
Console.WriteLine($"Difference: {((timeOne - timeSeveral) / (double)timeOne) * 100}%");
